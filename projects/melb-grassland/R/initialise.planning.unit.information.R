    #------------------------------------------------------------
    #             initialise.planning.unit.data.R               #
    #                                                           #
    #  For now have either square PUs generated by R code, or   #
    #  it is assumed that the PU map has been provided          #
    #                                                           #
    #  NOTE: only the options of user.supplied.planning.units   #
    #        and making rectangular.planning.units are          #
    #        implemented.                                       #
    #                                                           #
    #                                                           #
    #  Created 3/4/2009 AG                                      #
    #  source('initialise.planning.unit.information.R')         #
    #                                                           #
    #  31/5/2009 - BTL                                          #
    #  Added initialization of MANAGED field                    #
    #                                                           #
    #  01/6/2009 - BTL                                          #
    #  Added initialization of LEAKED field                     #
    #  Added initialization of OFFSET_INTO_PU field             #
    #------------------------------------------------------------

rm( list = ls( all=TRUE ));

    #------------------------------------------------------------
    #  Other code that needs to be sourced
    #------------------------------------------------------------

source( 'dbms.functions.R' )      
source( 'utility.functions.R' )
source( 'variables.R')
source( "GIS.utility.functions.R" )

    #------------------------------------------------------------
    #  variables needed
    #------------------------------------------------------------

# set in python
OPT.use.assessment.uncertainty <- FALSE

OPT.VAL.user.supplied.planning.units.from.raster <- 1
OPT.VAL.use.patches.as.planning.units <- 2
OPT.VAL.generate.rectangular.planning.units <- 3
OPT.VAL.generate.Mondrian.planning.units <- 4
OPT.VAL.user.supplied.planning.units.from.polygon <- 5

OPT.PU.source <- OPT.VAL.user.supplied.planning.units.from.raster

    #------------------------------------------------------------
    #  start code
    #------------------------------------------------------------


cat( '\nInitialising planning unit information' );

if( OPT.PU.source == OPT.VAL.user.supplied.planning.units.from.raster ) {


  cat( '\nUsing user supplied planning unit map' );
  
  # get the ids area areas for each planning unit.
  # this returns a table with 2 cols , PU_ID and PU_AREA
  
  non.habitat.indicator <- -9999
  pu.ids.and.areas.matrix <- get.num.pixels.for.each.id.from.map(
                              planning.units.filename, non.habitat.indicator );

  if( Debug.Test.With.given.num.of.PUs ) {
      pu.ids.and.areas.matrix <- pu.ids.and.areas.matrix[1:Debug.Num.of.PUs.to.test.with,];
  }

  pu.ids.vec <- pu.ids.and.areas.matrix[,1];

} else{


  if( OPT.PU.source == OPT.VAL.use.patches.as.planning.units  ) {

    # Note! make.patches.planning.units.R is from the first version
    # of the framework and may need to be altered to work with this
    # new sequential version
    
    source( 'make.patches.planning.units.R')

  } else {

    if(  OPT.PU.source == OPT.VAL.generate.rectangular.planning.units ) {

      cat( '\nGenerating rectangular planning unit file' );
      source( 'make.rectangular.planning.units.R' ) ;

      # get the areas of each PU. They may not all be equal is the PUs
      # do not tile the area completely
      
      pu.ids.and.areas.matrix <-
        get.num.pixels.for.each.id.from.map(planning.units.filename,
                                            non.habitat.indicator );
      pu.ids.vec <- pu.ids.and.areas.matrix[,1];

     
    } else {
      
      if( OPT.PU.source == OPT.VAL.generate.Mondrian.planning.units ) {
        
        # Note! make.Mondrian.planning.units.R is from the first
        # version of the framework and may need to be altered to
        # work with this new sequential version
        
        source( 'make.Mondrian.planning.units.R' );
        stop( '\nOPT.VAL.generate.Mondrian.planning.units is currently unimplemented',
             call. = FALSE )

      } else {

        if( OPT.PU.source == OPT.VAL.user.supplied.planning.units.from.polygon ) {

          cadastral.shape.file <- PAR.PU.information.shapefile
          
          PU.att.df <-
            extract.shape.file.attribute.table.to.data.frame( cadastral.shape.file )

          # TODO(Ascelin) - make this more general so there is a
          # variable specifiying the col name to get the PU ID from
          
          # in the attribute table from the CPW Castre we have the following mappings
          # CAD_GEOM_P -> parcel ID
          # area_ha -> area of the parcel in ha
          
          if( Debug.Test.With.given.num.of.PUs ) {

            pu.ids.vec <-
              as.numeric( as.vector( PU.att.df$CAD_GEOM_P[1:Debug.Num.of.PUs.to.test.with]))
            pu.area.vec <-
              as.numeric( as.vector( PU.att.df$area_ha[1:Debug.Num.of.PUs.to.test.with]))
            
          } else{
            
            pu.ids.vec <- as.numeric( as.vector( PU.att.df$CAD_GEOM_P ) )
            pu.area.vec <- as.numeric( as.vector( PU.att.df$area_ha ) )

          }

          # Build a matrix with the ids area areas for each planning unit.
          # PU_ID and PU_AREA
          # note rounding off the area to 4 decimal places (to save space in DB)
          pu.ids.and.areas.matrix <- cbind(  pu.ids.vec,  round(pu.area.vec,4) )
          

        } else {

          cat( '\nError: Planning Unit source :',
              '\n    OPT.PU.source = ', OPT.PU.source, '\n' );
          stop( '\nAborted due to error in input.', call. = FALSE );
        }
      }
    }
  }

}  # end if/else ( OPT.PU.source == OPT.VAL.user.supplied.PUs )

    #------------------------------------------------------------
    #  Generate developer and seller assessment biases for planning units
    #  and create matrices to insert values into db
    #------------------------------------------------------------

if(OPT.use.assessment.uncertainty)
{
  source( 'generate.pu.assessment.biases.R')
  
  if( PAR.Developer.error.st.deviation <= 0 || 
      PAR.Seller.error.st.deviation <= 0 )
  {
    stop( '\nAborted due to error in input:\nAssessment uncertainty std deviation must be >= zero.', call. = FALSE ); 
  }
  
  number.of.pus <- length(pu.ids.vec)
  
  developer.biases.mx <- matrix(0, nrow = number.of.pus, ncol = 2);
  seller.biases.mx <- matrix(0, nrow = number.of.pus, ncol = 2);
  
  biases.mx <- generate.pu.assessment.biases( 
                                  number.of.pus, 
                                  PAR.Developer.error.upper.bound,
                                  PAR.Developer.error.lower.bound, 
                                  PAR.Seller.error.upper.bound,
                                  PAR.Seller.error.lower.bound, 
                                  PAR.Developer.error.mean,
                                  PAR.Seller.error.mean,
                                  PAR.Developer.error.st.deviation,
                                  PAR.Seller.error.st.deviation );
                                  
  developer.biases.mx[,1] <- pu.ids.vec;
  developer.biases.mx[,2] <- biases.mx[,1];
  
  seller.biases.mx[,1] <- pu.ids.vec;
  seller.biases.mx[,2] <- biases.mx[,2];
}


    #------------------------------------------------------------
    #  Write this information the PU information database
    #------------------------------------------------------------



# this created the list of PUs in the dynamic table
insert.pu.ids.to.db( dynamicPUinfoTableName, pu.ids.vec, 'ID' );

# write the ID and AREA into the STATIC PU into table
# this creates the list of PUs and areas in the STATIC PU table
# NOTE: as the Static PU table is not being used for anything at presemt
# this operation is commented out to save time - AG 6 Dec 2010
#insert.pu.id.and.value.to.db(staticPUinfoTableName, pu.ids.and.areas.matrix,
#                              'AREA' )

# write the ID and AREA to the dynamic PU into table
#update.db.pu.ids.with.multiple.values( dynamicPUinfoTableName, pu.ids.and.areas.matrix,'AREA')
update.column.in.db.table.via.dataframe( dynamicPUinfoTableName, 'AREA', pu.ids.and.areas.matrix[,2] )


# set the RESERVED status to 0 for all PUs
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   0, 'RESERVED' );

update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   -999, 'TIME_RESERVED' );

# set the MANAGED status to 0 for all PUs
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   0, 'MANAGED' );

# set the PROB_RES_EXPIRING_PER_TIMESTEP status to 0 for all PUs
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   0, 'PROB_RES_EXPIRING_PER_TIMESTEP' );


# set the LEAKED status to 0 for all PUs
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   0, 'LEAKED' );

# set the OFFSET_INTO_PU to uninitialized value for all PUs
AG2.CONST.UNINITIALIZED.PU.ID.VALUE <- -999;
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                       AG2.CONST.UNINITIALIZED.PU.ID.VALUE,
                                       'OFFSET_INTO_PU' );

#### set the LANDUSE status to UNDEVELOPED for all PUs
###update.db.pu.ids.with.single.value(dynamicPUinfoTableName,
###                                   pu.ids.vec, '"UNDEVELOPED"', 'LANDUSE' );

#  Mark all PUs as being undeveloped.
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   0, 'DEVELOPED' );

update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   -999, 'TIME_DEVELOPED' );

# make all PUs available for development (in the development pool
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                   1,'IN_DEV_POOL' );


# note these values are updated for specific scenarios in when the
# loss model and initialised and OPT.use.offsetting.in.loss.model is
# true.

# mark all PUs as bing in the development pool
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                       1,'IN_DEV_POOL' );


#  Mark all PUs as being in the offset pool.
update.db.all.pu.ids.with.single.value(dynamicPUinfoTableName,
                                       1, 'IN_OFFSET_POOL' );

# write assessment biases into the dynamicPU table
if(OPT.use.assessment.uncertainty)
{
  update.db.pu.ids.with.multiple.values (dynamicPUinfoTableName,
                                         developer.biases.mx, 'DEVELOPER_ASSESSMENT_BIAS')
                                         
  update.db.pu.ids.with.multiple.values (dynamicPUinfoTableName,
                                         seller.biases.mx, 'SELLER_ASSESSMENT_BIAS')
}


#  Temporarily add something here for testing:
#  cbind the PU ids and a random value for each PU to use as its total
#  condition score.
#  Then, load those values into the database.
#  btl - 5/22/09.

  # make a dummy table containing PU Ids with some random values

#random.tot.scores <-
#    pu.ids.and.areas.matrix [,2] * runif (length (pu.ids.vec));
#pu.ids.and.random.cond.scores <- cbind (pu.ids.vec, random.tot.scores);


